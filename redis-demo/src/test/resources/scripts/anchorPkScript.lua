---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by gy.
--- DateTime: 2023/11/8 15:20
---
-- 调试配置相关代码，实际使用不需要 start--
--package.cpath = package.cpath .. ';/Users/gy/Library/Application Support/JetBrains/IntelliJIdea2023.2/plugins/EmmyLua/debugger/emmy/mac/x64/?.dylib'
--local dbg = require('emmy_core')
--dbg.tcpConnect('localhost', 9966)
--
---- redis相关配置
--local cjson = require 'cjson'
--local redis = require 'redis'
--local defaults = {
--    host = '127.0.0.1',
--    port = 6379,
--    tcp_nodelay = true,
--    path = nil
--}
--client = redis.connect(defaults)
---- 需要密码是启用
---- client:auth('wsd_data@douyu123')
--
--redis.call = function(cmd, ...)
--    return assert(load('return client:' .. string.lower(cmd) .. '(...)'))(...)
--end
-- 调试配置相关代码，实际使用不需要 end--

local handleType = "pkJoin"
-- pkId候场key
local pkIdWaitKey = "actqzs:cardArena1052:pk:awardPool:1"
-- pkId生成key
local pkIdGenerateKey = "actqzs:cardArena1052:pk:id"
-- pkId基本信息key
local pkIdInfoKeyPrefix = "actqzs:cardArena1052:pk:baseInfo"
-- 房间号与pkId映射key
local roomIdPkIdKey = "actqzs:cardArena1052:pk:room:0"
-- 奖励小时库存key
local awardHourStockKey = "actqzs:cardArena1052:pk:awardPool:hourStock:1:2023111317"
--奖励天库存key
local awardDayStockKey = "actqzs:cardArena1052:pk:awardPool:dayStock:1:20231113"

local param = "{\"joinRid\":77610537,\"serverTime\":1699867133098,\"ridLimit\":5,\"awardUniqueKey\":\"1_659\",\"awardNum\":1,\"awardLimit\":100,\"awardMax\":9223372036854775807,\"endTimeStep\":600000,\"pkId\":null,\"awardLevel\":1,\"awardKey\":\"1723992678652125184\",\"awardItem\":{\"awardKey\":\"1723992678652125184\",\"award\":{\"awardType\":1,\"awardId\":659,\"total\":100,\"num\":1},\"bcAward\":{\"awardType\":1,\"awardId\":659,\"total\":0,\"num\":0}},\"baseBlood\":10000,\"lockStock\":null,\"rids\":null,\"pkStatus\":null,\"createTime\":null,\"readyTime\":null,\"startTime\":null,\"endTime\":null}"
-- pkId基本信息参数
local baseInfoParam = cjson.decode(param)

local result = {
    error = 0,
    msg = "ok",
    pkBaseInfo = nil
}

-- 库存检查，返回值{成功处理的数量,是否需要初始化expire标记}
local function checkStock(key, field, num, limit)
    local ret = redis.call("HGET", key, field)
    local initFlag = false
    local canSendNum = 0
    if ret == nil or ret == false then
        canSendNum = math.min(num, limit)
        initFlag = true;
    else
        local oldNum = tonumber(ret)
        local addable = limit - oldNum
        if addable >= num then
            canSendNum = num
        elseif addable < num and addable > 0 then
            canSendNum = addable
        else
            canSendNum = 0
        end
    end
    return canSendNum, initFlag
end

-- 库存增量处理
local function updateStock(key, field, canSendNum, expire, initFlag)
    redis.call("HINCRBY", key, field, canSendNum)
    if initFlag ~= nil and initFlag == true then
        redis.call("EXPIRE", key, expire)
    end
end

-- 更新奖励库存数据
local function updateAwardStock(hourKey, dayKey, baseInfoParamObj)
    local num = baseInfoParamObj.awardNum
    local limit = baseInfoParamObj.awardLimit
    local field = baseInfoParamObj.awardUniqueKey
    local max = baseInfoParamObj.awardMax
    local expire = 86400 * 10
    -- 检查小时库存
    local canSendNum, hourInitFlag = checkStock(hourKey, field, num, limit)
    if canSendNum > 0 then
        -- 检查天库存
        local finalSendNum, dayInitFlag = checkStock(dayKey, field, canSendNum, max)
        if finalSendNum > 0 then
            -- 更新小时库存
            updateStock(hourKey, field, finalSendNum, expire, hourInitFlag)
            -- 更新天库存
            updateStock(dayKey, field, finalSendNum, expire, dayInitFlag)
        end
        return finalSendNum
    end
    return canSendNum
end

-- 创建pkId
local function createPkId(createPkIdKey)
    local pkId = redis.call("incr", createPkIdKey)
    redis.call("expire", createPkIdKey, 86400 * 60)
    return pkId
end

-- 获取候场pkId
local function getPkIdWait(pkWaitKey, awardKey)
    return redis.call("hget", pkWaitKey, awardKey)
end

-- 设置候场pkId
local function setPkIdWait(pkWaitKey, awardKey, pkId)
    redis.call("hset", pkWaitKey, awardKey, pkId)
    redis.call("expire", pkWaitKey, 86400 * 60)
end
-- 清理候场pkId
local function cleanPkIdWait(pkWaitKey, awardKey)
    redis.call("hdel", pkWaitKey, awardKey)
end

-- 获取房间对应的pkId
local function getRoomPkId(roomPkIdKey, roomId)
    return redis.call("hget", roomPkIdKey, tostring(roomId))
end

-- 设置房间对应的pkId
local function setRoomPkId(roomPkIdKey, roomId, pkId)
    redis.call("hset", roomPkIdKey, tostring(roomId), pkId)
    redis.call("expire", roomPkIdKey, 86400 * 60)
end

-- 生成baseInfo key
local function buildPkBaseInfoKey(prefixKey, pkId)
    return prefixKey .. ":" .. tostring(pkId)
end

-- 获取baseInfo
local function getPkBaseInfo(prefixKey, pkId, baseInfoObject)
    local redisKey = buildPkBaseInfoKey(prefixKey, pkId)
    local pkBaseInfo = {}
    local infoRedis = redis.call("hgetall", redisKey);
    if infoRedis == nil or next(infoRedis) == nil then
        pkBaseInfo["pkId"] = tonumber(pkId)
        pkBaseInfo["awardLevel"] = baseInfoObject["awardLevel"]
        pkBaseInfo["awardKey"] = baseInfoObject["awardKey"]
        pkBaseInfo["awardItem"] = cjson.encode(baseInfoObject["awardItem"])
        pkBaseInfo["baseBlood"] = baseInfoObject["baseBlood"]
        pkBaseInfo["rids"] = nil
        pkBaseInfo["pkStatus"] = 0
    else
        for k, v in pairs(infoRedis) do
            if k % 2 == 1 then
                pkBaseInfo[v] = infoRedis[k + 1]
            end
        end
    end
    return pkBaseInfo
end

-- 更新baseInfo
local function updatePkBaseInfo(prefixKey, pkId, baseInfoObject)
    local redisKey = buildPkBaseInfoKey(prefixKey, pkId)
    for key, value in pairs(baseInfoObject) do
        redis.call("hset", redisKey, key, value)
    end
    redis.call("expire", redisKey, 86400 * 60)
end

-- 初始化baseInfo
local function initPkBaseInfo(pkId, rid, baseInfoObject)
    -- 设置baseInfo
    local baseInfo = {}
    baseInfo["pkId"] = pkId
    baseInfo["awardLevel"] = baseInfoObject["awardLevel"]
    baseInfo["awardKey"] = baseInfoObject["awardKey"]
    baseInfo["awardItem"] = cjson.encode(baseInfoObject["awardItem"])
    baseInfo["baseBlood"] = baseInfoObject["baseBlood"]
    local rids = {}
    table.insert(rids, rid)
    baseInfo["rids"] = cjson.encode(rids)
    baseInfo["pkStatus"] = 10
    baseInfo["createTime"] = tonumber(baseInfoObject["serverTime"])
    return baseInfo
end

-- 检查是否存在
local function checkInTable(value, tbl)
    for _, v in pairs(tbl) do
        if v == value then
            return true;
        end
    end
    return false;
end

if handleType == "pkJoin" then
    -- 主播房间号
    local rid = tonumber(baseInfoParam["joinRid"])
    -- 检查房间是否在pk场次中
    local roomPkId = getRoomPkId(roomIdPkIdKey, rid)
    if roomPkId ~= nil and roomPkId ~= false then
        local pkBaseInfo = getPkBaseInfo(pkIdInfoKeyPrefix, roomPkId, baseInfoParam)
        if tonumber(pkBaseInfo["pkStatus"]) > 0 then
            result.error = 500001
            result.msg = "当前已在PK场次中，请勿重复加入"
            return { 0, cjson.encode(result) }
        end
    end
    -- 奖励等级参数
    local awardKeyField = baseInfoParam["awardKey"]
    -- 检查是否有候场pkId
    local waitPkId = getPkIdWait(pkIdWaitKey, awardKeyField)
    -- 没有候场pkId，则创建
    if waitPkId == nil or waitPkId == false then
        -- 校验库存
        local canSendNum = updateAwardStock(awardHourStockKey, awardDayStockKey, baseInfoParam)
        if canSendNum <= 0 then
            result.error = 500002
            result.msg = "当前奖励库存不足，换个奖励试试吧"
            return { 0, cjson.encode(result) }
        end
        waitPkId = createPkId(pkIdGenerateKey)
        -- 设置房间对应的pkId
        setRoomPkId(roomIdPkIdKey, rid, waitPkId)
        -- 设置候场pkId
        setPkIdWait(pkIdWaitKey, awardKeyField, waitPkId)
        -- 设置baseInfo
        local baseInfo = initPkBaseInfo(waitPkId, rid, baseInfoParam)
        baseInfo["lockStock"] = canSendNum
        updatePkBaseInfo(pkIdInfoKeyPrefix, waitPkId, baseInfo)
        result.pkBaseInfo = baseInfo
        return { 0, cjson.encode(result) }
    else
        -- 有候场pkId
        local pkBaseInfo = getPkBaseInfo(pkIdInfoKeyPrefix, waitPkId, baseInfoParam)
        local rids = {}
        if pkBaseInfo["rids"] ~= nil then
            rids = cjson.decode(pkBaseInfo["rids"])
        end
        if checkInTable(rid, rids) == true then
            result.error = 500001
            result.msg = "当前已经在PK场次中，刷新一下试试吧"
            return { 0, cjson.encode(result) }
        end
        local ridLimit = 5
        if baseInfoParam["ridLimit"] ~= nil then
            ridLimit = baseInfoParam["ridLimit"]
        end
        if #rids >= ridLimit then
            result.error = 500003
            result.msg = "当前场次已经满员，换个奖励试试吧"
            return { 0, cjson.encode(result) }
        end
        if tonumber(pkBaseInfo["pkStatus"]) >= 30 then
            result.error = 500004
            result.msg = "当前场次已经开始，换个奖励试试吧"
            return { 0, cjson.encode(result) }
        end
        -- 校验库存
        local canSendNum = updateAwardStock(awardHourStockKey, awardDayStockKey, baseInfoParam)
        if canSendNum <= 0 then
            result.error = 500002
            result.msg = "当前奖励库存不足，换个奖励试试吧"
            return { 0, cjson.encode(result) }
        end
        -- 加入主播pk房间列表
        table.insert(rids, rid)
        pkBaseInfo["rids"] = cjson.encode(rids)
        if #rids == 1 then
            pkBaseInfo["pkStatus"] = 10
            pkBaseInfo["createTime"] = tonumber(baseInfoParam["serverTime"])
        elseif #rids == 2 then
            -- 如果有两个人，则进入准备状态
            pkBaseInfo["pkStatus"] = 20
            pkBaseInfo["readyTime"] = tonumber(baseInfoParam["serverTime"])
        elseif #rids == ridLimit then
            -- 如果人数满了，则直接开始
            pkBaseInfo["pkStatus"] = 30
            pkBaseInfo["startTime"] = tonumber(baseInfoParam["serverTime"])
            pkBaseInfo["endTime"] = tonumber(baseInfoParam["serverTime"]) + tonumber(baseInfoParam["endTimeStep"])
            --场次已经开始，则删除候场pkId
            cleanPkIdWait(pkIdWaitKey, awardKeyField)
        end
        -- 设置房间对应的pkId
        setRoomPkId(roomIdPkIdKey, rid, waitPkId)
        -- 设置baseInfo
        pkBaseInfo["lockStock"] = canSendNum
        updatePkBaseInfo(pkIdInfoKeyPrefix, waitPkId, pkBaseInfo)
        result.pkBaseInfo = pkBaseInfo
        return { 0, cjson.encode(result) }
    end
else
    -- 异常操作
    return { -999 }
end
